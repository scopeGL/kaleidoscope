<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Caleidoscopio WebGL Nítido</title>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: black;
}
canvas { display: block; }
</style>
</head>

<body>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const uniforms = {
  u_time: { value: 0 },
  u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    precision highp float;

    uniform float u_time;
    uniform vec2 u_resolution;

    #define PI 3.14159265359

    vec3 palette(float t) {
      return 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0;
      uv.x *= u_resolution.x / u_resolution.y;

      // ROTACIÓN CLARA
      float rot = u_time * 0.5;
      float c = cos(rot);
      float s = sin(rot);
      uv = mat2(c, -s, s, c) * uv;

      float r = length(uv);
      float a = atan(uv.y, uv.x);

      // CALEIDOSCOPIO
      float slices = 14.0;
      float slice = 2.0 * PI / slices;
      a = mod(a, slice);
      a = abs(a - slice * 0.5);

      // ZOOM SUAVE
      r *= 1.0 + 0.15 * sin(u_time * 1.2);

      vec2 p = vec2(cos(a), sin(a)) * r;

      // FACETAS DURAS (DETALLE)
      vec2 cell = fract(p * 12.0) - 0.5;
      float dist = max(abs(cell.x), abs(cell.y));

      // BORDES NÍTIDOS
      float edge = smoothstep(0.48, 0.46, dist);

      // ALTA FRECUENCIA
      float detail = sin(p.x * 20.0) * sin(p.y * 20.0);

      float t = detail * 0.3 + u_time * 0.15;

      vec3 color = palette(t);

      // COMBINAR FACETA + COLOR
      color *= edge;

      // CONTRASTE FINAL
      color = pow(color, vec3(0.7));

      gl_FragColor = vec4(color, 1.0);
    }
  `
});

const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
scene.add(quad);

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
});

function animate(time) {
  uniforms.u_time.value = time * 0.001;
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Caleidoscopio WebGL Óptico</title>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: black;
}
canvas { display: block; }
</style>
</head>

<body>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

const uniforms = {
  u_time: { value: 0 },
  u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
};

const material = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    precision highp float;

    uniform float u_time;
    uniform vec2 u_resolution;

    #define PI 3.14159265359

    vec3 spectrum(float t) {
      return vec3(
        0.6 + 0.4 * cos(6.2831 * (t + 0.00)),
        0.6 + 0.4 * cos(6.2831 * (t + 0.33)),
        0.6 + 0.4 * cos(6.2831 * (t + 0.66))
      );
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy / u_resolution) * 2.0 - 1.0;
      uv.x *= u_resolution.x / u_resolution.y;

      // ROTACIÓN ÓPTICA
      float rot = u_time * 0.4;
      float c = cos(rot);
      float s = sin(rot);
      uv = mat2(c, -s, s, c) * uv;

      float r = length(uv);
      float a = atan(uv.y, uv.x);

      // CALEIDOSCOPIO
      float slices = 10.0;
      float slice = 2.0 * PI / slices;
      a = abs(mod(a, slice) - slice * 0.5);

      // REFRACCIÓN RADIAL
      float bend = 0.25 * sin(r * 6.0 - u_time * 2.0);
      r += bend;

      vec2 p = vec2(cos(a), sin(a)) * r;

      // CAPAS DE COLOR DESPLAZADAS (NITIDEZ ÓPTICA)
      float d1 = sin(p.x * 6.0 + u_time);
      float d2 = sin(p.y * 6.0 - u_time * 1.3);
      float d3 = sin((p.x + p.y) * 6.0);

      float t = (d1 + d2 + d3) * 0.15 + u_time * 0.1;

      vec3 color = spectrum(t);

      // VIGNETTE SUAVE (PROFUNDO, NO BORROSO)
      float vignette = smoothstep(1.2, 0.2, r);
      color *= vignette;

      // CONTRASTE ÓPTICO (SIN LÍNEAS)
      color = pow(color, vec3(0.75));

      gl_FragColor = vec4(color, 1.0);
    }
  `
});

const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
scene.add(quad);

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
});

function animate(time) {
  uniforms.u_time.value = time * 0.001;
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

animate();
</script>

</body>
</html>
